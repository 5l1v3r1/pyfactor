% Section on the number field sieve 
% gets included in the report.tex file 


Let $N$ be a positive composite integer that is not a prime power. The general number field sieve is the result of 30 years of evolution of same general idea: To factor $N$, one may find integers $x,y$ such that $x \not\equiv y$ mod $N$ but $x^2 \equiv y^ 2$ mod $N$. Once these integers are found, we will know $N$ divides $(x - y)(x+y)$. Since $N$ is not prime by assumption, it is likely (about half the time) that one of $\text{gcd}(x-y,N)$ or  $\text{gcd}(x+y,N)$ is non-trivial. The first algorithm to leverage this idea was designed by John Dixon at Carleton University in [\ref{JohnDixon}]. His key insight was that producing congruences of squares modulo $N$ could be done using a factor base of primes. His technique seeked integers with squares mod N are \textit{smooth} over those primes. This simple idea has been extrapolated into what is now known to the fastest factoring algorithm ever implemented, the general number field sieve. 


%% quick description of dixons algorithm
\subsection{Dixon's Method}
  Let $F = \lbrace 2,3,...,p_t \rbrace$ be a set of consecutive prime numbers. An integer $z$ is “$F$-smooth” if $z = 2^{e_1} \cdots p_t^{e_t} $ where $e_1,...,e_t \in \mathbb{Z}^+$. Dixons big idea was to collect a set of integers $A = \lbrace x \in \Z \mid x^2 \text{ is }F\text{-smooth mod } N \rbrace $ with $s = | A | $. Then write these squares in the form $x_i^2 = 2^{e_{1i}}  \cdots p_{t}^{e_{ti}} \text{ mod } N$ for $i = 1,...,s$ and place them in a matrix as 

  $$
  \begin{pmatrix}
    e_{11} \text{ mod } 2 & e_{21} \text{ mod } 2 & \cdots & e_{t1} \text{ mod } 2 \\
    e_{12} \text{ mod } 2 & e_{22} \text{ mod } 2 & \cdots & e_{t2} \text{ mod } 2 \\
    \vdots  & \vdots  & \ddots & \vdots  \\
    e_{1s} \text{ mod } 2 & e_{2s} \text{ mod } 2 & \cdots & e_{ts} \text{ mod } 2 
   \end{pmatrix}
  $$

  If $s>t$ then there are more rows than colums. So there exists a subset $U \subset A$ whos corresponding rows are linearly dependent, which means that they sum to the zero vector or equiviently all the prime exponents are $0$ mod $2$. This means that 

  $$
  (\prod_{x_i \in U}x_i)^2 \equiv \prod_{x_i \in U}x_i^2 \equiv 2^{2f_1} \cdots p_t^{2f_t} \equiv (2^{f_1} \cdots p_t^{f_t})^2 \text{ mod } N \text{ where } f_j = \frac{\sum_{x_i \in U} e_{ji}}{2} 
  $$

  Let $x= \prod_{x_i \in U}x_i $ and $y = 2^{f_1} \cdots p_t^{f_t}$, then $x^2 \equiv y^2$ mod $N$. 

%% Quick description of the quadratic sieve 
\subsection{Quadratic Sieve}
  The bottleneck of Dixon's Mathod is constructing the set $A = \lbrace x \in \Z \mid x^2 \text{ is }F\text{-smooth mod } N \rbrace$. Initially, this was done by randomly choosing integers less than $N$ and squaring them. This bottleneck was radically circumvented in 1981 by Carl Pomerance with his idea to instead use the factor base to find smooth integers mod $N$. His idea was the combination of two key observations: When trying to find smooth squares mod N, if $x$ is an integer in the range $\sqrt{N} < x < \sqrt{N} + N^\delta $ (for some small positive delta), then $x^2 - N \approx N^{1/2 + \delta}$. This means that if we let $f(x) = x^2 - N $, then as $x$ takes values starting from $\sqrt{N}$, then the values of $f(x)$ are small squares mod $N$. Secondly, if $x_1,x_2$ are a roots of $f(x)= x^2 - N$, then so are $x_1 + kp,x_2 + lp$ for every integer $k,l$. Keeping these two facts in mind the idea of the quadratic sieve is to initialize two arrays

  \begin{align*}
    R &= [\ceil*{{\sqrt{N}}},\ceil*{{\sqrt{N}}}+ 1, ..., \ceil*{\sqrt{N}} + N^\delta] \\
    \text{LogR} &= [\log(f(\ceil*{\sqrt{N}}) \text{ mod } N), \log(f(\ceil*{\sqrt{N}}+1) \text{ mod } N),..., \log(f(\ceil*{\sqrt{N}}  + N^\delta) \text{ mod } N)] 
  \end{align*}

  where $\text{LogR}[i] = \log(f(R[i]))$ for all $i$. Then for each $p_j$ in the factor base $F = \lbrace 2,3,...,p_t \rbrace $, iterate through $R$ checking if $p_j$ divides $f(R[i])$ mod $N$, if it does subtract $\log(p_j)$ from $\text{LogR}[i + kp_j]$ for all $0 \leq k,l < \floor*{\frac{N}{p_j}}$ and skip to the next prime $p_{j+1}$. Once this is done for all primes in the factor base, scan through the array LogR and look for values which are approximately $0$. These values are $F$-smooth mod $N$. This is because if a value satisfies $f(R[i]) = 2^{e_1} \cdots p_t^{e_t}$ then 
  $$ 
    \log(f(R[i])) - e_1\log(2) - ... - e_t \log(p_t) = \log(\frac{f(R[i])}{2^{e_1} \cdots p_t^{e_t}}) = \log(1) = 0
  $$

  Once these $F$-smooth integers $f(R[i])$ are found, they are placed in a matrix the same way as in Dixon's algorithm. Although the quadractic sieve offered significant speed up, the slowest step was still finding smooth squares mod $N$. There just aren't enough smooth elements in the integers mod $N$!     
   
%% Quick description of the quadratic sieve
\subsection{The Number Field Sieve} 
  Followign the success of the Quadratic Sieve, researchers experiemented with various elements of the algorithm. One insight was that the polynomial $f(x) = x^2 - N $ used in the quadratic sieve doesn't necessarily have to be quadratic for the algorithm to work! The other key insight was that the integers are just a \hyperref[ring]{\textit{ring}} with the usual operations of addition and multiplication and there are other rings which have the similar notions of smoothness. Perhaps these rings may have "more" smooth elements than the ring of regular integers. The following section describes such a ring. If the reader is confortable loosing some of the intuition behind the algorithm, they may choose to skip to section \ref{algo}

  \subsubsection{Algebraic Intuition} \label{intuition}
    Let $f(x)$ be a monic (leading coefficient is $1$) irreducible polynomial of degree $d$ in $\mathbb{Z}[x]$. By the \hyperref[fun]{\textit{fundamental theorem of algebra}}, $f(x)$ has exactly $d$ complex roots $\theta_1, ... , \theta_d$. Choose one of these roots and call it $\theta$, then one may consider the set $\Z[\theta]$ of all $\Z$-linear combinations of the elements $\lbrace 1,\theta,\theta^2,...,\theta^{d-1} \rbrace $. Given elements $g =  a_0 + a_1\theta + ... + a_n\theta^n $ and $ h= b_0 + b_1 \theta + ... + b_m \theta^m $ in $ \Z[\theta]$ with $m < n < d$, let $G(x),H(x) \in \mathbb{Z}[x] $ such that $G(\theta) = g, H(\theta) = h $. Note that we may use the polynomial divison algorithm to write $G(x)H(x) = C(x)f(x) + D(x)$ where $C(x), D(x) \in Z[x]$ and $\deg(f(x)) >  \deg (D(x))$. Therefore $ G(\theta) H(\theta) = C(\theta)f(\theta) + D(\theta) = 0 + D(\theta) = D(\theta) $. If we let $d = D(\theta)$, then the operations  
    \begin{align*}
    g+ h &=  (a_0 + b_0) + (a_1 + b_1) \theta + \dots + (a_n + b_n )\theta^n \\
    g \cdot  h &= d
    \end{align*}
    defines the structure of a ring on the set $\Z[\theta]$. This ring is actually a subring of the \hyperref[field]{\textit{field}} $\Q(\theta)$ which is isomorphic to $\Q[x]/(f)$ and thus the two operations decribed above are inherited from the field $\Q(\theta)$. Besides making the following definition of a "norm" function on $\Q(\theta)$, this fact will generally be ignored for the purposes of this report. Recall that $f$ has precisely $d$ roots $\theta_1, ... , \theta_d$ over $\mathbb{C}$ and we chose one of them and called it $\theta$. For $i = 1,...,d$ let $\sigma_i : \Q(\theta) \longrightarrow \Q(\theta_i)$ be a set map defined by the action; $\sigma_i(\Q) = \Q$ and $\sigma_i(\theta) = \theta_i$. It turns out that these $\sigma_i$ are precisely all the embedding of $\Q(\theta) $ into $\mathbb{C}$, but again this can be ignored. Define the "norm" function $N$ on $\Q(\theta)$ to be a set map $\Q(\theta) \overset{N}{\longrightarrow} \mathbb{C}$ with action $\alpha \mapsto \sigma_1(\alpha) \sigma_2(\alpha), ... , \sigma(\alpha)$. It is a standard result from algebra that $N$ is a multiplicative function which maps $Q(\theta)$ to $\Z$ and thus likewise for $\Z[\theta]$. This norm function $N$ will be a very important link between the two rings $\Z$ and $\Z[\theta]$. \\

    Since $\Z[\theta]$ is a ring, we may consider \hyperref[ideal]{\textit{ideals}} in $Z[\theta]$. Furthermore, since $\Z[\theta]$ is in fact a \hyperref[dedekind]{\textit{Dedekind domain}}, an ideal $I$ of $\Z[\theta]$ may be uniquely factored, up to order, as the product $I = \mathfrak{p}_1^{e_1} \mathfrak{p}_2^{e_2} \cdots \mathfrak{p}_t^{e_t}$ of \hyperref[primeideal]{\textit{prime ideals}} $ \mathfrak{p}_1, \mathfrak{p}_2, ... , \mathfrak{p}_t \in \Z[\theta]$. Two more facts are necissary before it will become apparent why all this algebra is required. We may also define the norm $N$ on an ideal of $I \in \mathbb{Z}[\theta]$ as $N(I) = [\mathbb{Z}[\theta]: I]$. That is, the number of cosets of $I$ in $\mathbb{Z}[\theta]$. It turns out that this definition agrees with our earlier definition in the sense that $\mid N(\alpha)\mid  = N(\langle \alpha \rangle )$. Secondly, if $\mathfrak{p}$ is an ideal of $\mathbb{Z}[\theta]$ such that $N(\mathfrak{p}) = p$ for some prime $p$, then $\mathfrak{p}$ is a prime ideal. Conversly, if $\mathfrak{p}$ is a prime ideal of $\mathbb{Z}[\theta]$, then $N(\mathfrak{p}) = p^e$ for prime $p \in \Z$ and possitve exponent $e$. The point is of all this is, for $\alpha \in \mathbb{Z}[\theta]$ with factorization $\alpha = \mathfrak{p}_1^{e_1} \mathfrak{p}_2^{e_2} \cdots \mathfrak{p}_t^{e_t}$, then

    \begin{align*}
      \norm{N(\alpha)} & = N(\langle \alpha \rangle) \\
      &=N(\mathfrak{p}_1^{e_1} \mathfrak{p}_2^{e_2} \cdots \mathfrak{p}_t^{e_t}) \\
      &=N(\mathfrak{p}_1)^{e_1}N(\mathfrak{p}_2)^{e_2} \cdots N(\mathfrak{p}_2)^{e_t} \\
      &=(p_1^{f_1})^{e_1}(p_2^{f_2})^{e_2} \cdots (p_t^{f_t})^{e_t} \\
      &=p_1^{f_1 + e_1}p_2^{f_2 + e_2} \cdots p_t^{f_t + e_t}
    \end{align*}
    for some (not necissarly destinct) primes $p_1, p_2, ..., p_t$ and possitive exponents $f_1,f_2,...,f_t$. Essentially, we have been able to relate questions about factorization in $\Z[\theta]$ to questions of factorization in $\Z$. The high level idea is to choose a set $\A$ of prime ideals in $\Z[\theta]$, called an "algebraic factor base" which we will use analogously to our factor base in the integers. The idea is to try an find pairs $(a,b)$ for which the element $a + b \theta$ has a principal ideal $\langle a+ b \theta \rangle$ that factors as the product of prime ideals which are in $\A$. We call this being smooth over $\A$. \\

    Two technical problems remains - storing representations of prime ideals in $\Z[\theta]$ on a computer and determining whether an algebraic element of $\Z[\theta]$ is a square. \\ 

    The former can be overcome by only comprising one's factor base of prime ideals $\mathfrak{p}$ which satisfy $N(\mathfrak{p})=p$ for some prime $p$. One can show that these ideals, called "first degree prime ideals", are the only prime ideals apearing in the prime ideal factorization of a principal idea $\langle a + b \theta \rangle $ for coprime integers $a,b\in \Z$ in $\Z[\theta]$. What makes these types of ideals perfect for computing is that they are in natural bijection with the set of all pairs $(r,p)$ where $p$ is a prime and $r$ satisfying $f(r) \equiv 0$ mod $p$. Furthermore, there is a easy to check condition for determining whether a first degree prime ideal occurs in the ideal factorization of $\langle a + b \theta \rangle $. Specifically, a first degree prime ideal with representation $(r,p)$ occurs in the ideal factorization of an element $\langle a + b \theta \rangle $ if and only if $a \equiv -br $ mod $p$. To summarize, finding an element $\langle a + b \theta \rangle $ that is smooth over an algebraic factor base of first degree prime ideals of $\Z[\theta]$ amounts to finding an element $a + b \theta $ such that the integer $N(a + b \theta)$ factors completely over the primes occurring in the $(r,p)$ pairs corresponding to the first degree prime ideals in the algebraic factor base. \\

    To determine whether an element $\beta$ is a square in $\Z[\theta]$, Let 


\subsubsection{Algorithm} \label{algo}

 
\begin{algorithm} 
  \caption{The general number field sieve to factorize an integer $N$}
  \begin{algorithmic}[1]
    \State \Return{$N$}
  \end{algorithmic} 
\end{algorithm} 

\subsubsection{Implementation}


\begin{minted}[mathescape,
               linenos,
               numbersep=5pt,
               gobble=2,
               frame=lines,
               framesep=2mm]{csharp}
  /*
  Here will be the python code.
  use xelatex -shell-escape report.tex to compile 
  */

\end{minted}



