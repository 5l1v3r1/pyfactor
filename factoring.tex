Integer factorization is the decomposition of a composite number into a product of prime powers. This means that the number can be represented as the multiplication of prime numbers to certain powers. This factorization is also unique. Given a large integer, finding this factorization into prime powers in a tractable manner (in polynomial time) is still an open problem. The decision form of this problem is: does the integer $N$ have a prime number factor less than $M$, whereas the regular problem is in function form (i.e. finding all the factors). That means there is a single output for each input to the problem, but it is more complicated than a yes or no. In this case, the output is the set of factors for $N$. That sets it apart from $NP$-Complete problems, putting the problem in a different complexity class. This problem is in the $FNP$ complexity class. It is not known however whether the problem is in $FP$ (meaning it is polynomial) or not, similar to how we are not sure if $P = NP$. The problem is not currently known to have a polynomial runtime algorithm, which is why it is not in $FP$. \\

This report covers information about the problem, its applications and two algorithms for the problem. This report will explain why this problem is important in the computing field, primarily in cryptography. The algorithms covered are the General Number Field Sieve (GNFS) and Shor’s algorithm. Analysis will be performed on GNFS, with respect to time and runtime complexity. With Shor’s algorithm, because it requires quantum computing, only a theoretical analysis will be done.


\subsection{Brute Force Attempts}
	To understand the time complexity of the brute force algorithm, we first need to explain how a brute force algorithm would proceed. To be brute force, we need to check all possible numbers that could be factors. This is all the numbers from $2$ to $\sqrt{N}$. We stop at $\sqrt{N}$ because $N$ can only have one factor that is larger than $\sqrt{N}$. Any two numbers larger than $\sqrt{N}$ multiplied together would produce a number larger than $N$. We would repeat this process until the remaining number to be factored is $1$, meaning we have found all the factors of $N$. \\

	When determining the complexity of the algorithm it is standard to use the bit length of $N$ as the size of the input. So the complexity does not depend on the number $N$ itself as we mentioned earlier. The size of $N$ is really the number of bits it takes to represent $N$, or $\text{lg}(N) = k$ bits. The number that we can represent with k bits is $2^k$. It is evident by looking at that, that the number we can represent when we increase $k$ rises exponentially. Additionally, the number of factors we have is also the same as the number of bits, because in the worse case, all our factors can be 2, and so the factorization of our number would just look like $2^k$. So if for the moment, we think of $N$ being the size of the input, that is to say, the number we are factoring takes $N$ bits to represent, our complexity is $O(2^n)$.


\subsection{Some Applications}
	Integer factorization is the basis of most modern forms of cryptography and therefore is of huge importance in cyber security. The concept is used in encryption techniques such as RSA, to come up with “secure” numbers. Part of the process is multiplying two very large prime numbers together to come up with your RSA key. The whole idea works on the assumption that it would be very difficult to factor an incredibly large number (in the order of $1000$ bits) if it only had two prime factors, because the problem is non-polynomial (to our knowledge). Another stipulation to the system is that the factors have to both be approximately the same bit length, one can’t be very small, and the other very large, or the brute force algorithm may be able to crack it in a reasonable amount of time. So on that basis, if someone were to alternatively find an efficient way to do the factorization, the setup would no longer be secure. This would be a huge issue, because many computing systems rely on that property for security, not just RSA, so they would all become insecure unless an alternate cryptographic system was built. \\ 

	Consequently, if the solution was in $FP$, it could also help lead to proving $P=NP$ [\ref{saad1}]. Another application of integer factorization is in calculating Fast Fourier Transforms (referred to as FFT). The FFT is an algorithm used to calculate the Discrete Fourier Transform (DFT). The classic algorithm for calculating the DFT is polynomial time, but quite inefficient, the FFT algorithms can calculate the same results but much faster using integer factorization. The DFT is used in the field of image processing to perform spectral analysis on images [\ref{saad2}], and image convolution[\ref{saad3}]. The aforementioned applications are basically used for extracting data from images or for image manipulation. DFT has applications in other fields, such as data compression[\ref{saad4}].