Integer factorization is the decomposition of a composite number into a product of prime powers. This means that the number can be represented as the multiplication of prime numbers to certain powers. This factorization is also unique. Given a large integer, finding this factorization into prime powers in a tractable manner (in polynomial time) has not been figured out. The decision form of this problem is does the integer $N$ have a prime number less than $M$, whereas the regular problem is in function form (finding the factors). That means there is a single output for each input to the problem, but it is more complicated than a yes or no, in this case the output is the set of factors for $N$. That sets it apart from $NP$-Complete problems, putting the problem in a different complexity class. The problem is in the FNP complexity class. It is not known, however whether the problem is in $FP$ (meaning it is polynomial) or not, similar to how we are not sure if $P=NP$-complete. The problem is not known to be a polynomial runtime functional problem, which is why it is not in $FP$. \\

This paper covers information about the problem, its applications, two algorithms for the problem. The paper will explain why this problem is important in the computing field, primarily in cryptography. The algorithms covered are general number field sieve and Shor’s algorithm. Analysis will be performed on the general number field sieve, with respect to time and runtime complexity. With Shor’s algorithm, because it requires quantum computing, instead only a theoretical analysis will be done. 


\subsection{Brute Force Attempts}

	To understand the runtime of the brute force algorithm, we need to explain the algorithm first. In brute force, we need to check all possible numbers that are could be factors, so that would be all the numbers from $2$ to $\sqrt{N}$. We stop at $\sqrt{N}$ because $N$ can only have one factor that is larger than $\sqrt{N}$. Any two numbers larger than $\sqrt{N}$ multiplied together would produce a number larger than $N$. We would repeat that until the number resulting by dividing by the factor is $1$, meaning we have found all the numbers factors. \\

	The complexity becomes exponential when we go back to the idea that the complexity relies on the size of the input. So the complexity does not depend on the number $N$ itself we mentioned earlier. The size of $N$ is really the number of bits it takes to represent $N$, or $\text{lg}(N) = k$ bits. The number that we can represent with $k$ bits is $2^k$. It is evident by looking at that, that the number we can represent when we increase $k$ rises exponentially. Additionally, the number of factors we have is also the same as the number of bits, because in the worse case, all our factors can be $2$, and so the factorization of our number would just look like $2^k$. So if for the moment, we think of $N$ being the size of the input, that is to say, the number we are factoring takes $N$ bits to represent, our complexity is $O(2^n)$.


\subsection{Some Applications}

	Integer factorization is the basis of most modern forms of cryptography and therefore is of huge importance in cyber security. The concept is used in encryption techniques such as RSA, to come up with “secure” numbers. Part of the process is multiplying two very large prime numbers together to come up with your RSA key. The whole idea works on the assumption that it would be very difficult to factor an incredibly large number (in the order of $1000$ bits) if it only had two prime factors, because the problem is non polynomial (to our knowledge). Another stipulation to the system is that the factors have to both be large, one can’t be very small, and the other very large, or the brute force algorithm may be able to crack it in a reasonable amount of time. So on that basis, if someone were to alternatively find an efficient way to do the factorization, the setup would no longer be secure. This would be a huge issue, because many computing systems rely on that property for security, not just RSA, so they would all become insecure unless an alternate cryptographic system built. \\

	Consequently, if the solution was in FP, it could also help lead to proving $P=NP$ [1]. Another application of integer factorization is in calculating Free Fourier Transforms (referred to as FFT). The FFT is an algorithm used to calculate the Discrete Fourier Transform (DFT). The classic algorithm for calculating the DFT is polynomial time, but quite inefficient, the FFT algorithms can calculate the same results but much faster using integer factorization. The DFT is used in the field of image processing to perform spectral analysis on images [2], and image convolution [3]. The aforementioned applications are basically used for extracting data from images or for image manipulation. DFT has applications in other fields as well such as data compression [4]. 