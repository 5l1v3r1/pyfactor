\documentclass[10pt,a4paper]{article}
\usepackage{
  amsmath,amsfonts,euscript,enumerate,mathrsfs,
  hyperref,amsthm,amssymb,upref,graphics,color
}

\usepackage[all]{xy}
\hypersetup{
  colorlinks,breaklinks,urlcolor=blue,linkcolor=black
  }

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Theorems 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \swapnumbers %% numbering for theorems will be on the left
\theoremstyle{plain} 
  \newtheorem{theorem}[subsection]{Theorem}
  \newtheorem*{thmnonumber}{Theorem}
  \newtheorem{proposition}[subsection]{Proposition}
  \newtheorem{lemma}[subsection]{Lemma}
  \newtheorem*{lemmanonumber}{Lemma}
  \newtheorem{corollary}[subsection]{Corollary}
  \newtheorem*{cornonumber}{Corollary}
  \newtheorem{nothing}[subsection]{}
  \newtheorem{sheafificationThm}[subsection]{Sheafification Theorem}
  \newtheorem{subtheorem}{Theorem}[subsection]
  \newtheorem{subproposition}[subtheorem]{Proposition}
  \newtheorem{sublemma}[subtheorem]{Lemma}
  \newtheorem{subcorollary}[subtheorem]{Corollary}
  \newtheorem{subnothing}[subtheorem]{}

\theoremstyle{definition}
  \newtheorem{definition}[subsection]{Definition}
  \newtheorem{definitions}[subsection]{Definitions}
  \newtheorem*{definonumber}{Definition}
  \newtheorem{nothing*}[subsection]{}
  \newtheorem{example}[subsection]{Example}
  \newtheorem{examples}[subsection]{Examples}
  \newtheorem*{solution}{Solution}
  \newtheorem*{exnonumber}{Example}
  \newtheorem*{quesnonumber}{Question}
  \newtheorem{question}{Question}
  \newtheorem{problem}[subsection]{Problem} 
  \newtheorem{exercise}[subsection]{Exercise} 
  \newtheorem{notation}[subsection]{Notation}
  \newtheorem{notations}[subsection]{Notations}
  \newtheorem{step}{Step}
  \newtheorem*{claim}{Claim}
  \newtheorem{assumptions}[subsection]{Assumptions}
  \newtheorem{subdefinition}[subtheorem]{Definition}
  \newtheorem{subnotation}[subtheorem]{Notation}
  \newtheorem{subnotations}[subtheorem]{Notations}
  \newtheorem{subexample}[subtheorem]{Example}
  \newtheorem{subnothing*}[subtheorem]{}

\theoremstyle{remark}
  \newtheorem*{remark}{Remark}
  \newtheorem*{remarks}{Remarks}
  \newtheorem*{warning}{Warning}
  \newtheorem*{smallexample}{Example}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Macros (Most acronyms come from french)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\DeclareMathOperator*{\OVplus}{\oVplus} 

\newcommand{\coker}{    \oVperatorname{{\rm coker}}}
\newcommand{\Aut}{    \oVperatorname{{\rm Aut}}}
\newcommand{\Spec}{   \oVperatorname{{\rm Spec}}}
\newcommand{\Proj}{   \oVperatorname{{\rm Proj}}}
\newcommand{\rank}{   \operatorname{{\rm rank}}}
\newcommand{\Reg}{    \operatorname{{\rm Reg}}}
\newcommand{\haut}{   \operatorname{{\rm ht}}}
\newcommand{\supp}{   \operatorname{{\rm supp}}}
\newcommand{\image}{  \operatorname{{\rm im}}}
\newcommand{\ord}{    \operatorname{{\rm ord}}}
\newcommand{\bideg}{  \operatorname{{\rm bideg}}}
\newcommand{\trdeg}{  \operatorname{{\rm trdeg}}}
\newcommand{\Frac}{   \operatorname{{\rm Frac}}}
\newcommand{\Char}{   \operatorname{{\rm char}}}
\newcommand{\Span}{   \operatorname{{\rm Span}}}
\newcommand{\Sing}{   \operatorname{{\rm Sing}}}
\newcommand{\Pic}{    \operatorname{{\rm Pic}}}
\newcommand{\Cl}{   \operatorname{{\rm Cl}}}
\newcommand{\dom}{    \operatorname{{\rm dom}}}
\newcommand{\codom}{  \operatorname{{\rm codom}}}
\renewcommand{\div}{  \operatorname{{\rm div}}}
\newcommand{\id}{   \operatorname{{\rm id}}}
\newcommand{\ob}{   \operatorname{{\rm ob}}}
\newcommand{\Hom}{    \operatorname{{\rm Hom}}}
\newcommand{\Set}{    \operatorname{{\rm\bf Set}}}
\newcommand{\Top}{    \operatorname{{\rm\bf Top}}}
\newcommand{\Grp}{    \operatorname{{\rm\bf Grp}}}
\newcommand{\CRng}{   \operatorname{{\rm\bf CRng}}}

\newcommand{\Mod}[1]{\mbox{\rm ${#1}$-\bf Mod}}
\newcommand{\setspec}[2]{\big\{\,#1\, \mid \,#2\, \big\}}
\newcommand{\powerset}{\raisebox{\depth}{\Large $\wp$}}

\newcommand{\notdiv}{\not\hspace{\mylength}\mid}
\newcommand{\epi}{\twoheadrightarrow}
\newcommand{\overepi}[1]{\overset{ #1 }{\epi}}
\newcommand{\monic}{\rightarrowtail}
\newcommand{\overmonic}[1]{\overset{ #1 }{\monic}}
\newcommand{\Integ}{\ensuremath{\mathbb{Z}}}
\newcommand{\Nat}{\ensuremath{\mathbb{N}}}
\newcommand{\Rat}{\ensuremath{\mathbb{Q}}}
\newcommand{\Comp}{\ensuremath{\mathbb{C}}}
\newcommand{\Reals}{\ensuremath{\mathbb{R}}}
\newcommand{\aff}{\ensuremath{\mathbb{A}}}
\newcommand{\proj}{\ensuremath{\mathbb{P}}}
\newcommand{\bk}{{\ensuremath{\rm \bf k}}}
\newcommand{\ck}{{\bar{\bk}}}
\newcommand{\kk}[1]{\bk^{[#1]}}

\newcommand{\Aeul}{\EuScript{A}}
\newcommand{\Beul}{\EuScript{B}}
\newcommand{\Ceul}{\EuScript{C}}
\newcommand{\Deul}{\EuScript{D}}
\newcommand{\Eeul}{\EuScript{E}}
\newcommand{\Feul}{\EuScript{F}}
\newcommand{\Geul}{\EuScript{G}}
\newcommand{\Heul}{\EuScript{H}}
\newcommand{\Keul}{\EuScript{K}}
\newcommand{\Oeul}{\EuScript{O}}
\newcommand{\Peul}{\EuScript{P}}
\newcommand{\Seul}{\EuScript{S}}

\newcommand{\Acal}{\mathcal{A}}
\newcommand{\Bcal}{\mathcal{B}}
\newcommand{\Ccal}{\mathcal{C}}
\newcommand{\Dcal}{\mathcal{D}}
\newcommand{\Ecal}{\mathcal{E}}
\newcommand{\Fcal}{\mathcal{F}}
\newcommand{\Gcal}{\mathcal{G}}
\newcommand{\OV}{\mathcal{O}}

\newcommand{\pgoth}{\mathfrak{p}}
\newcommand{\Pgoth}{\mathfrak{P}}
\newcommand{\qgoth}{\mathfrak{q}}
\newcommand{\Qgoth}{\mathfrak{Q}}
\newcommand{\m}{\mathfrak{m}}
\newcommand{\M}{\mathfrak{M}}

%%% DEAL With these later
\newcommand{\Q}{\mathbb{Q}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\Z}{\mathbb{Z}}
% \newcommand{\C}{\mathbb{C}}
\newcommand{\K}{\mathbb{K}}
\newcommand{\N}{\mathbb{N}}
\newcommand{\FP}{F_P}
\newcommand{\PF}{\mathbb{P}_F}
\newcommand{\LL}{\mathscr{L}} %% RRP 
\newcommand{\Leul}{\mathscr{L}} %% Dimension  of the RRP
\newcommand{\ldim}{\EuScript{l}}
\newcommand{\A}{\mathcal{A}_F}
\newcommand{\notzero}{\backslash \lbrace 0 \rbrace }
\newcommand{\IDEALa}{\mathfrak{a}}

\newcommand{\IDEALp}{\mathfrak{p}}
\newcommand{\fX}{f(X) = a_0 + a_1X + ... + a_nX^n}
\newcommand{\fx}{f(x) = a_0 + a_1x + ... + a_nx^n}
\newcommand{\ket}{\big \rangle}
\newcommand{\bra}{\big \langle}

\newcommand{\Abf}{\mathbf{A}}
\newcommand{\Bbf}{\mathbf{B}}
\newcommand{\Cbf}{\mathbf{C}}
\newcommand{\Dbf}{\mathbf{D}}
\newcommand{\Ebf}{\mathbf{E}}

\newcommand{\PP}{\mathbb{P}}
\newcommand{\PPP}{\mathbb{P}}
\newcommand{\SSS}{\mathbb{S}}
\newcommand{\VV}{\mathbb{V}}
\newcommand{\VVV}{\mathbb{V}}

\newcommand{\dirlim}{\varinjlim}
\newcommand{\ssi}{\Leftrightarrow}
\newcommand{\isom}{\cong}
\renewcommand{\epsilon}{\varepsilon}
\renewcommand{\phi}{\varphi}
\renewcommand{\emptyset}{\varnothing}
\newcommand{\rien}[1]{}
\renewcommand{\baselinestretch}{1.07}
\newcommand{\HRule}{\rule{\linewidth}{0.5mm}} 
\newcommand{\HtRule}{\rule{\linewidth}{0.2mm}} 


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Pages sizing
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% \setlength{\textwidth}{15.5cm}
% % \setlength{\mylength}{1.45\mylength}
% % \settowidth{\mylength}{$\,$}
% \addtolength{\oddsidemargin}{-1cm}
% \addtolength{\evensidemargin}{-1cm}
% \addtolength{\textheight}{14mm}

% \raggedbottom
% \CompileMatrices
% \newlength{\mylength}

\setlength\parindent{0pt}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Unique to this document
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


% Embedded python 
\usepackage{minted}

\usepackage{mathtools}
\DeclarePairedDelimiter\ceil{\lceil}{\rceil}
\DeclarePairedDelimiter\floor{\lfloor}{\rfloor}

% norms ! !!!  
\usepackage{commath}

% Algorithm template 
% \begin{algorithm} 
%   \caption{Description of the algrithm }
%   \begin{algorithmic}[1]
%     \Function{ScalarMult}{$m$,$P$}
%         \If{$m = 0 $}
%           \State \Return{$\mathcal{O}$}
%         \ElsIf{$m = 1 $}
%           \State \Return{$P$}
%         \ElsIf{$m \equiv 0 \text{ mod } 2$}
%           \State \Return{\Call{ScalarMult}{$m/2$,$P + P$}}
%         \Else 
%           \State \Return{$P$ + \Call{ScalarMult}{$m-1$,$P$}}
%         \EndIf
%       \EndFunction
%   \end{algorithmic} 
% \end{algorithm} 


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Docuemnt 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%TODO


<<<<<<< HEAD

\begin{document}
\tableofcontents

=======
\begin{document}
>>>>>>> 48501069da59935e41408009d1a1ccf947a6d8cf
\section{Factoring}
\section{The General Number Field Sieve}


<<<<<<< HEAD
Let $N$ be a positive composite integer that is not a prime power. The general number field sieve is a result of 30 years of evolution of same general idea: finding integers $x,y$ such that $x \not\equiv y$ mod $N$ but $x^2 \equiv y^ 2$ mod $N$. Once these integers are found, we know $N$ divides $(x - y)(x+y)$. Since $N$ is not prime by assumption, it is likely (about half the time) that one of $\text{gcd}(x-y,N)$ or  $\text{gcd}(x+y,N)$ is non-trivial. The first algorithm to leverage this idea was designed by John Dixon at Carleton University [ref dixon]. The key insight was that producing congruences of squares modulo $N$ could be done using a factor base of primes. The technique seeks integers with squares mod N are \textit{smooth} over those primes. This simple idea has been extrapolated into what is now known to the fastest factoring algorithm ever implemented, the number field sieve. 
=======
Let $N$ be a positive composite integer that is not a prime power. The general number field sieve is a result of 30 years of evolution of same general idea: finding integers $x,y$ such that $x \not\equiv y$ mod $N$ but $x^2 \equiv y^ 2$ mod $N$. Once these integers are found, we know $N$ divides $(x - y)(x+y)$. Since $N$ is not prime by assumption, it is likely (about half the time) that one of $\text{gcd}(x-y,N)$ or  $\text{gcd}(x+y,N)$ is non-trivial. The first algorithm to leverage this idea was designed by John Dixon at Carleton University [ref dixon]. The key insight was that producing congruences of squares modulo $N$ could be done using a factor base of primes. The technique seeks integers with squares mod N are \textit{smooth} over those primes. This simple idea has been extrapolated into what is now known to the fastest factoring algorithm ever implemented, the number field sieve. \\
>>>>>>> 48501069da59935e41408009d1a1ccf947a6d8cf

%% quick description of dixons algorithm
\subsection{Dixon's Method}
  Let $F = \lbrace 2,3,...,p_t \rbrace$ be a set of consecutive prime numbers. An integer $z$ is “$F$-smooth” if $z = 2^{e_1} \cdots p_t^{e_t} $ where $e_1,...,e_t \in \mathbb{Z}^+$. Dixons big idea was to collect a set of integers $A = \lbrace x \in \Z \mid x^2 \text{ is }F\text{-smooth mod } N \rbrace $ with $s = \mid A \mid $. Then write these squares in the form $x_i^2 = 2^{e_{1i}}  \cdots p_{t}^{e_{ti}} \text{ mod } N$ for $i = 1,...,s$ and place them in a matrix as 

  $$
  \begin{pmatrix}
    e_{11} \text{ mod } 2 & e_{21} \text{ mod } 2 & \cdots & e_{t1} \text{ mod } 2 \\
    e_{12} \text{ mod } 2 & e_{22} \text{ mod } 2 & \cdots & e_{t2} \text{ mod } 2 \\
    \vdots  & \vdots  & \ddots & \vdots  \\
    e_{1s} \text{ mod } 2 & e_{2s} \text{ mod } 2 & \cdots & e_{ts} \text{ mod } 2 
   \end{pmatrix}
  $$

  If $s>t$ then there are more rows than colums. Then there exists a subset $U \subset A$ whos corresponding rows are linearly dependent, which means that they sum to the zero vector. This means that 
  $$
  (\prod_{x_i \in U}x_i)^2 \equiv \prod_{x_i \in U}x_i^2 \equiv 2^{2f_1} \cdots p_t^{2f_t} \equiv (2^{f_1} \cdots p_t^{f_t})^2 \text{ mod } N \text{ where } f_j = \frac{\sum_{x_i \in U} e_{ji}}{2} 
  $$

  Let $x= \prod_{x_i \in U}x_i $ and $y = 2^{f_1} \cdots p_t^{f_t}$, then $x^2 \equiv y^2$ mod $N$. 

%% Quick description of the quadratic sieve 
\subsection{Quadratic Sieve}
  The bottleneck of Dixon's Mathod is constructing the set $A = \lbrace x \in \Z \mid x^2 \text{ is }F\text{-smooth mod } N \rbrace$. Initially, this was done by randomly choosing integers less than $N$ and squaring them. This was radically improved in 1981 by Carl Pomerance with his idea to instead use the factor base to find smooth integers mod $N$. His idea was the combination of two key observations: When trying to find smooth squares mod N, if $x$ is an integer in the range $\sqrt{N} < x < \sqrt{N} + N^\delta $ for some small positive delta, then $x^2 - N \approx N^{1/2 + \delta}$. This means that if we let $f(x) = x^2 - N $, then as $x$ takes values starting from $\sqrt{N}$, then the values of $f(x)$ are small squares mod $N$. Secondly, if $x_1,x_2$ are a roots of $f(x)= x^2 - N$, then so are $x_1 + kp,x_2 + lp$ for every integer $k,l$. Keeping these two facts in mind the idea of the quadratic sieve is to initialize two arrays

  \begin{align*}
    R &= [\ceil*{{\sqrt{N}}},\ceil*{{\sqrt{N}}}+ 1, ..., \ceil*{\sqrt{N}} + N^\delta] \\
    \text{LogR} &= [\log(f(\ceil*{\sqrt{N}}) \text{ mod } N), \log(f(\ceil*{\sqrt{N}}+1) \text{ mod } N),..., \log(f(\ceil*{\sqrt{N}}  + N^\delta) \text{ mod } N)] 
  \end{align*}

  where $\text{LogR}[i] = \log(f(R[i]))$ for all $i$. Then for each $p_j$ in the factor base $F = \lbrace 2,3,...,p_t \rbrace $, iterate through $R$ checking if $p$ divides $f(R[i])$ mod $N$, if it does subtract $\log(p_j)$ from $\text{LogR}[i + kp_j]$ for all $0 \leq k < \floor*{\frac{N}{p_j}}$ and skip to the next prime $p_{j+1}$. Once this is done for all primes in the factor base, scan through the array LogR and look for values which are approximately $0$. These values are $F$-smooth mod $N$. This is because if a value satisfies $f(R[i]) = 2^{e_1} \cdots p_t^{e_t}$ then 
  $$ 
    \log(f(R[i])) - e_1\log(2) - ... - e_t \log(p_t) = \log(\frac{f(R[i])}{2^{e_1} \cdots p_t^{e_t}}) = \log(1) = 0
  $$

  Once these $F$-smooth integers $f(R[i])$ are found, they are placed in a matrix the same way as in Dixon's algorithm. 
   
%% Quick description of the quadratic sieve
\subsection{The Number Field Sieve}
  Followign the success of the Quadratic Sieve, researchers experiemented with various elements of the algorithm. One insight was that the polynomial $f(x) = x^2 - N $ used in the quadratic sieve doesn't necessarily have to be quadratic! The other key insight was that there are \hyperref[ring]{\textit{rings}} which have the similar notions of smoothness and may have "more" smooth elements that the regular integers. The following section describes such a ring. If the reader is confortable loosing some of the intuition behind the algorithm, they may choose to skip to section \ref{procedure}
  \subsubsection{Algebraic Intuition}
    Let $f(x)$ be a monic irreducible polynomial of degree $d$ in $\mathbb{Z}[x]$. By the \hyperref[fun]{\textit{fundamental theorem of algebra}}, $f(x)$ has exactly $d$ complex roots $\theta_1, ... , \theta_d$. Choose one of these roots $\theta$, then one may consider the set $\Z[\theta]$ of all $\Z$-linear combinations of the elements $\lbrace 1,\theta,\theta^2,...,\theta^{d-1} \rbrace $. Given $g =  a_0 + a_1\theta + ... + a_n\theta^n $ and $ h= b_0 + b_1 \theta + ... + b_m \theta^m $ in $ \Z[\theta]$ with $m < n < d$, let $G(x),H(x) \in \mathbb{Z}[x] $ such that $G(\theta) = g, H(\theta) = h $. Note that we may write $G(x)H(x) = C(x)f(x) + D(x)$ where $C(x), D(x) \in Z[x]$ and $\deg(f(x)) >  \deg (D(x))$. Therefore $ G(\theta) H(\theta) = C(\theta)f(\theta) + D(\theta) = 0 + D(\theta) = D(\theta) $. If we let $d = D(\theta)$, then with the operations  
    \begin{align*}
    g+ h &=  (a_0 + b_0) + (a_1 + b_1) \theta + \dots + (a_n + b_n )\theta^n \\
    g \cdot  h &= d
    \end{align*}
<<<<<<< HEAD
    the set $\Z[\theta]$ forms a ring. This ring is actually a subring of the \hyperref[field]{\textit{field}} $\Q(\theta)$ which is isomorphic to $\Q[x]/(f)$ and thus the two operations decribed above are inherited from the field $\Q(\theta)$. Besides making the following definition of a "norm" function on $\Q(\theta)$, this fact will generally be ignored for the purposes of this report. Recall that $f$ has precisely $d$ roots $\theta_1, ... , \theta_d$ over $\mathbb{C}$ and we chose one of them and called it $\theta$. For $i = 1,...,d$ let $\sigma_i : \Q(\theta) \longrightarrow \Q(\theta_i)$ be defined by the action; $\sigma_i(\Q) = \Q$ and $\sigma_i(\theta) = \theta_i$. It turns out that these $\sigma_i$ are precisely all the embedding of $\Q(\theta) $ into $\mathbb{C}$, but again this can be ignored. Define the "norm" function $N$ on $\Q(\theta)$ to be a set map $\Q(\theta) \overset{N}{\longrightarrow} \mathbb{C}$ with action $\alpha \mapsto \sigma_1(\alpha) \sigma_2(\alpha), ... , \sigma(\alpha)$. It is a standard result from algebra that $N$ is a multiplicative function which maps $Q(\theta)$ to $\Z$ and thus likewise for $\Z[\theta]$. This will norm function $N$ will be a very important link between the two rings $\Z$ and $\Z[\theta]$. \\

    Since $\Z[\theta]$ is a ring, we may consider \hyperref[ideal]{\textit{ideals}} in $Z[\theta]$. Furthermore, since $\Z[\theta]$ is in fact a \hyperref[dedekind]{\textit{Dedekind domain}}, an ideal $I$ of $\Z[\theta]$ may be uniquely factored, up to order, as the product $I = \mathfrak{p}_1^{e_1} \mathfrak{p}_2^{e_2} \cdots \mathfrak{p}_t^{e_t}$ of \hyperref[primeideal]{\textit{prime ideals}} $ \mathfrak{p}_1, \mathfrak{p}_2, ... , \mathfrak{p}_t \in \Z[\theta]$. Two more facts are necissary before it will become apparent why all this algebra is required. We may also define the norm $N$ on an ideal of $I \in \mathbb{Z}[\theta]$ as $N(I) = [\mathbb{Z}[\theta]: I]$. That is, the number of cosets of $I$ in $\mathbb{Z}[\theta]$. It turns out that this definition agrees with our earlier definition in the sense that $\mid N(\alpha)\mid  = N(\langle \alpha \rangle )$. Secondly, if $\mathfrak{p}$ is an ideal of $\mathbb{Z}[\theta]$ such that $N(\mathfrak{p}) = p$ for some prime $p$, then $\mathfrak{p}$ is a prime ideal. Conversly, if $\mathfrak{p}$ is a prime ideal of $\mathbb{Z}[\theta]$, then $N(\mathfrak{p}) = p^e$ for prime $p \in \Z$ and possitve exponent $e$. The point is of all this is, for $\alpha \in \mathbb{Z}[\theta]$ with factorization $\alpha = \mathfrak{p}_1^{e_1} \mathfrak{p}_2^{e_2} \cdots \mathfrak{p}_t^{e_t}$, then
=======
    the set $\Z[\theta]$ forms a ring. This ring is actually a subring of the \hyperref[field]{\textit{field}} $\Q(\theta)$ which is isomorphic to $\Q[x]/(f)$ and thus the two operations decribed above are inherited from the field $\Q(\theta)$. Besides making the following definition of a "norm" function on $\Q(\theta)$, this fact will generally be ignored for the purposes of this report. Recall that $f$ has precisely $d$ roots $\theta_1, ... , \theta_d$ over $\mathbb{C}$ and we chose one of them and called it $\theta$. For $i = 1,...,d$ let $\sigma_i : \Q(\theta) \longrightarrow \Q(\theta_i)$ be defined by the action; $\sigma_i(\Q) = \Q$ and $\sigma_i(\theta) = \theta_i$. It turns out that these $\sigma_i$ are precisely all the embedding of $\Q(\theta) $ into $\mathbb{C}$, but again this can be ignored. Define the "norm" function $N$ on $\Q(\theta)$ to be a set map $\Q(\theta) \overset{N}{\longrightarrow} \mathbb{C}$ with action $\alpha \mapsto \sigma_1(\alpha) \sigma_2(\alpha), ... , \sigma(\alpha)$. It is a standard result from algebra that $N$ is a multiplicative function which maps $Q(\theta)$ to $\Z$ and thus likewise for $\Z[\theta]$. This will norm function $N$ will be a very important link between the two rings $\Z$ and $\Z[\theta]$. Since $\Z[\theta]$ is a ring, we may consider \hyperref[ideal]{\textit{ideals}} in $Z[\theta]$. Since $\Z[\theta]$ is a \hyperref[dedekind]{\textit{Dedekind domain}}, an ideal $I$ of $\Z[\theta]$ may be uniquely factored, up to order, as the product $I = \mathfrak{p}_1^{e_1} \mathfrak{p}_2^{e_2} \cdots \mathfrak{p}_t^{e_t}$ of \hyperref[primeideal]{\textit{prime ideals}} $ \mathfrak{p}_1, \mathfrak{p}_2, ... , \mathfrak{p}_t \in \Z[\theta]$. Two more facts are necissary before it will become apparent why all this algebra is required. We may also define the norm $N$ on an ideal of $I \in \mathbb{Z}[\theta]$ as $N(I) = [\mathbb{Z}[\theta]: I]$. That is, the number of cosets of $I$ in $\mathbb{Z}[\theta]$. It turns out that this definition agrees with our earlier definition in the sense that $\mid N(\alpha)\mid  = N(\langle \alpha \rangle )$. Secondly, if $\mathfrak{p}$ is an ideal of $\mathbb{Z}[\theta]$ such that $N(\mathfrak{p}) = p$ for some prime $p$, then $\mathfrak{p}$ is a prime ideal. Conversly, if $\mathfrak{p}$ is a prime ideal of $\mathbb{Z}[\theta]$, then $N(\mathfrak{p}) = p^e$ for prime $p \in \Z$ and possitve exponent $e$. The point is of all this is, for $\alpha \in \mathbb{Z}[\theta]$ with factorization $\alpha = \mathfrak{p}_1^{e_1} \mathfrak{p}_2^{e_2} \cdots \mathfrak{p}_t^{e_t}$, then
>>>>>>> 48501069da59935e41408009d1a1ccf947a6d8cf
    \begin{align*}
      \norm{N(\alpha)} & = N(\langle \alpha \rangle) \\
      &=N(\mathfrak{p}_1^{e_1} \mathfrak{p}_2^{e_2} \cdots \mathfrak{p}_t^{e_t}) \\
      &=N(\mathfrak{p}_1)^{e_1}N(\mathfrak{p}_2)^{e_2} \cdots N(\mathfrak{p}_2)^{e_t} \\
      &=(p_1^{f_1})^{e_1}(p_2^{f_2})^{e_2} \cdots (p_t^{f_t})^{e_t} \\
      &=p_1^{f_1 + e_1}p_2^{f_2 + e_2} \cdots p_t^{f_t + e_t}
    \end{align*}

<<<<<<< HEAD
    for some (not necissarly destinct) primes $p_1, p_2, ..., p_t$ and possitive exponents $f_1,f_2,...,f_t$. Essentially, we have been able to relate questions about factorization in $\Z[\theta]$ to questions of factorization in $\Z$. The high level idea is to choose a set $\A$ of prime ideals in $\Z[\theta]$, called an "algebraic factor base" which we will use analogously to our factor base in the integers. The idea is to try an find pairs $(a,b)$ for which the element $a + b \theta$ has a principal ideal $\langle a+ b \theta \rangle$ that factors as the product of prime ideals which are in $\A$. We call this being smooth over $\A$. Two technical problems remains - storing representations of prime ideals in $\Z[\theta]$ on a computer and determining whether an algebraic element of $\Z[\theta]$ is a square. \\ 

    The former can be overcome by only comprising one's factor base of prime ideals $\mathfrak{p}$ which satisfy $N(\mathfrak{p})=p$ for some prime $p$. One can show that these ideals, called "first degree prime ideals", are the only prime ideals apearing in the prime ideal factorization of a principal idea $\langle a + b \theta \rangle $ for coprime integers $a,b\in \Z$ in $\Z[\theta]$. What makes these types of ideals perfect for computing is that they are in natural bijection with the set of all pairs $(r,p)$ where $p$ is a prime and $r$ satisfying $f(r) \equiv 0$ mod $p$. Furthermore, there is a easy to check condition for determining whether a first degree prime ideal occurs in the ideal factorization of $\langle a + b \theta \rangle $. Specifically, a first degree prime ideal with representation $(r,p)$ occurs in the ideal factorization of an element $\langle a + b \theta \rangle $ if and only if $a \equiv -br $ mod $p$. To summarize, finding an element $\langle a + b \theta \rangle $ that is smooth over an algebraic factor base of first degree prime ideals of $\Z[\theta]$ amounts to finding an element $a + b \theta $ such that the integer $N(a + b \theta)$ factors completely over the primes occurring in the $(r,p)$ pairs corresponding to the first degree prime ideals in the algebraic factor base. \\

    To determine whether 
    
    \subsubsection{Algorithm} \label{procedure}
    \subsubsection{Implementation} \label{implementation}
=======
    for some (not necissarly destinct) primes $p_1, p_2, ..., p_t$ and possitive exponents $f_1,f_2,...,f_t$. In summation, we have been able to relate questions about factorization in $\Z[\theta]$ to questions of factorization in $\Z$. The high level idea is to choose a set $\A$ of prime ideals in $\Z[\theta]$, called an "algebraic factor base" which we will use analogously to our factor base in the integers. The idea is to try an find pairs $(a,b)$ for which the element $a + b \theta$ has a principal ideal $\langle a+ b \theta \rangle$ that factors as the product of prime ideals which are in $\A$. We call this being smooth over $\A$. One technical problem remains - storing representations of prime ideals in $\Z[\theta]$ on a computer. This can be overcome by only comprising one's factor base of prime ideals $\mathfrak{p}$ which satisfy $N(\mathfrak{p})=p$ for some prime $p$. One can show that these ideals, called "first degree prime ideals", are the only prime ideals apearing in the prime ideal factorization of a principal idea $\langle a + b \theta \rangle $ for coprime integers $a,b\in \Z$ in $\Z[\theta]$. What makes these types of ideals perfect for computing is that they are in natural bijection with the set of all pairs $(r,p)$ where $p$ is a prime and $r$ satisfying $f(r) \equiv 0$ mod $p$. Furthermore, This representation is the key to making the algorithm computationally feasable.  
    \subsubsection{Procedure} \label{procedure}




  % In particular, we are interested in prime ideals $\mathfrak{p}$ with the property their norm function satisfies $N(\mathfrak{p}) = p$ for a prime $p$. We call these ideals "first degree prime ideals"


\section{Shor's Quantum Algorithm}

\section{Conclusion}

\section{Implementation}

>>>>>>> 48501069da59935e41408009d1a1ccf947a6d8cf
\begin{minted}[mathescape,
               linenos,
               numbersep=5pt,
               gobble=2,
               frame=lines,
               framesep=2mm]{csharp}
  /*
  Here will be the python code.
  use xelatex -shell-escape report.tex to compile 
  */
<<<<<<< HEAD
\end{minted}





  % In particular, we are interested in prime ideals $\mathfrak{p}$ with the property their norm function satisfies $N(\mathfrak{p}) = p$ for a prime $p$. We call these ideals "first degree prime ideals"


\section{Shor's Quantum Algorithm}

\section{Conclusion}


=======


\end{minted}
>>>>>>> 48501069da59935e41408009d1a1ccf947a6d8cf
\section{Theorems and Definitions}
  \begin{definition} \label{dedekind} %(\textit{Dedekind Domain})

  \end{definition}

  \begin{definition} \label{field} %(\textit{Field})
    A \emph{field} $F$ is a \hyperref[ring]{ring} satifying the following extra conditions
    \begin{enumerate}
      \item If $0,1$ are the respective additive and multiplicative identities of $F$, then $1 \neq 0$
      \item If $a,b \in F$, then $a\cdot b = b \cdot a$ 
      \item For all $a \in F \backslash \lbrace 0 \rbrace $ there exists $b \in F \backslash \lbrace 0 \rbrace $ such that $ab = ba = 1$
    \end{enumerate}
  \end{definition}

  \begin{theorem} \label{fun} (\textit{Fundamental Theorem of Algebra})
    Let $f \in \mathbb{C}[Z]$ be a non-constant polynomial.  Then there is a $z\in\mathbb{C}$ with $f(z)=0$.
  \end{theorem}
  \begin{proof}
    Let C be the finite set of critical points of $f$. C is finite by elementary algebra. Remove from the codomain f(C) (and call the resulting open set B) and from the domain its inverse image (again finite) (and call the resulting open set A). Now you get an open map from A to B, which is also closed, because any polynomial is proper (inverse images of compact sets are compact). But B is connected and so $f$ is surjective.
  \end{proof}

  \begin{definition} \label{ideal} %(\textit{Ideal})
    An \emph{ideal} of a \hyperref[ring]{ring} $R$ is non-empty subset satisfying: 
    \begin{enumerate}
      \item If $x,y \in I$, then $x - y \in I$ 
      \item For all $r \in R$ and $x \in I$, both $rx,xr \in I$
    \end{enumerate}
  \end{definition}

  \begin{definition} \label{primeideal}% (\textit{Prime Ideal})
    An \hyperref[ideal]{ideal} $\mathfrak{p}$ of a \hyperref[ring]{ring} $R$ is \emph{prime} if:
    \begin{enumerate}
      \item For all $a,b \in R$, if $ab \in \mathfrak{p}$, then $a \in \mathfrak{p}$ or $b \in \mathfrak{p}$
      \item $\mathfrak{p}$ does not eqaul the whole ring $R$
    \end{enumerate}
  \end{definition}

  \begin{definition} \label{ring} %(\textit{Ring})
    A \emph{ring} is a set $R$ together with two binary operations, denoted $+: R \times R \longrightarrow R$ and $\cdot: R \times R \longrightarrow R$, such that
    \begin{enumerate}
      \item $(a+b)+c = a+(b+c)$ and $(a \cdot b) \cdot c = a \cdot (b \cdot c)$ for all $a,b,c \in R$ (associative law)
      \item $a+b = b+a$ for all $a,b \in R$ (commutative law)
      \item There exists elements $0,1 \in R$ such that $a+0 = 0 + a = a $ and $a\cdot1 = 1 \cdot a = a $ for all $a \in R$ (additive and multiplicative identities)
      \item For all $a \in R$, there exists $b \in R$ such that $a+b = 0$ (additive inverse)
      \item $a\cdot(b+c) = (a \cdot b) + (a \cdot c)$ and $(a+b) \cdot c = (a \cdot c) + (b \cdot c)$ for all $a,b,c \in R$ (distributive law)
    \end{enumerate}
  \end{definition}

\section{References}
\end{document}




